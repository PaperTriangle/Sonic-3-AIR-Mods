global bool lsds.leftshift
global bool lsds.noflicker
global bool lsds.alphashadow
global bool lsds.nodetail

global u16 oldposy = 0

function void DataSelect.setup()
{
	base.DataSelect.setup()
	
	if (lsds.leftshift)
	{
		camera.foreground.x.u16 += getScreenExtend()
		u16[0xffffe002] -= getScreenExtend()
		u16[0xffffb000 + 0x14] += 0x05
	}

}

//# address-hook(0x00d1b6) end(0x00d1f4)
function void fn00d1b6()
{
	if (!lsds.leftshift)
	{
		base.fn00d1b6()
		return
	}
	
	D0.u16 = 0xa8
	D1 = 0
	D2 = dataselect.slot_selected - 1
	while (D2.s16 >= 0)
	{
		D4 = 0x0c
		while (D4.s16 >= 0)
		{
			if (D0.u16 > 0x0118 + getScreenExtend() && D1.u16 <= 0x02b8 + getScreenExtend())
			{
				D1.u16 += 8
			}
			else
			{
				D0.u16 += 8
			}
			--D4.s16
		}
		--D2.s16
	}

	u16[A0 + 0x12] = D0.u16
	camera.foreground.x.u16 = D1.u16
	u16[0xffffe002] = -D1.s16

	objA0.update_address = 0x00d1fa
	fn00d1fa()
}


//# address-hook(0x00d1fa) end(0x00d30a)
function void fn00d1fa()
{
	if (!lsds.leftshift)
	{
		base.fn00d1fa()
		return
	}
	
#if STANDALONE
	if (u16[0xffffeee4] == 0 && (control.pad1.pressed & DataSelect.CONTROLS_CANCEL || Input.buttonPressed(BUTTON_BACK)))
#else
	if (u16[0xffffeee4] == 0 && (control.pad1.pressed & DataSelect.CONTROLS_CANCEL))
#endif
	{
		// Back to the intro / title screen
		global.game_mode = 0x04

	#if STANDALONE
		playSound(0xad)
		DataSelect.drawCustomPlanes()	// Required here, otherwise we can have one frame without custom plane setup if returning already during the fade-in

		u32 backupA0 = A0
		FadeOutScreenBlocking()
		A0 = backupA0

		// Do not fade out music in this case, Data Select music is meant to keep playing
		Game.returnToMainMenu()
		yieldExecution()
	#endif
	}
	else if (u16[0xffffeee2] == 0)
	{
		bool skipPart = false
		if (u16[A0 + 0x30] == 0)
		{
			D0 = 0
			if (control.pad1.pressed & CONTROL_LEFT)
			{
				if (u16[0xffffeee4] == 0 || dataselect.slot_selected != 1)
				{
					if (dataselect.slot_selected != 0)
					{
						--dataselect.slot_selected
						u8 sfx = (u16[0xffffeee4] != 0) ? 0x7b : 0xb7
						playSound(sfx)
						D0 = -8
					}
				}
			}
		#if STANDALONE
			else	// Don't allow both left & right being pressed at the same time, as this leads to buggy behavior
		#endif
			if (control.pad1.pressed & CONTROL_RIGHT)
			{
				if (dataselect.slot_selected != 9)
				{
					++dataselect.slot_selected
					u8 sfx = (u16[0xffffeee4] != 0) ? 0x7b : 0xb7
					playSound(sfx)
					D0 = 8
				}
			}

			objA0.countdown_value = D0.u16
			if (objA0.countdown_value != 0)
			{
				u16[A0 + 0x30] = 0x0d
			}
			else
			{
				skipPart = true
			}
		}

		if (!skipPart)
		{
			D0.u16 = u16[A0 + 0x12]		// Position of cursor on screen
			s16 moveStep = objA0.countdown_value

			D0.s16 += moveStep
			if (moveStep >= 0)
			{
				if (D0.s16 > s16(0x120 + getScreenExtend()))
				{
					camera.foreground.x.u16 += moveStep
					if (s16(camera.foreground.x.u16) > s16(0x2c0 - getScreenExtend() * 2))
					{
						camera.foreground.x.u16 -= moveStep
					}
					else
					{
						D0.s16 -= moveStep
					}
				}
			}
			else
			{
				if (D0.s16 < s16(0x120 + getScreenExtend()))
				{
					camera.foreground.x.u16 += moveStep
					if (s16(camera.foreground.x.u16) < 0x0000)
					{
						camera.foreground.x.u16 -= moveStep
					}
					else
					{
						D0.s16 -= moveStep
					}
				}
			}

			u16[A0 + 0x12] = D0.u16
			--u16[A0 + 0x30]
		}
	}

	D2 = 0
	if (dataselect.slot_selected == 0)
	{
		D2.s16 = 8
	}
	else if (dataselect.slot_selected == 9)
	{
		D2.s16 = -8
	}

	D2.u16 += u16[A0 + 0x12]
	objA0.position.x.u16 = D2.u16

	// Determine size of the cursor (large or small)
	objA0.animation.sprite = (D2.u16 >= 0xf0 && D2.u16 <= 0x148 + getScreenExtend() * 2) ? 1 : 2

	if (level.framecounter.low & 0x04)
	{
		DrawObject()
	}
}

function void DataSelect.update()
{
	if (!lsds.noflicker)
	{
		base.DataSelect.update()
		return
	}
	while (true)
	{
		global.frame_state = 0x1e
		waitForNextFrame()
	@EntryPoint:

		DataSelect.drawCustomPlanes()


		++level.framecounter
		UpdateGameObjects()
		u16[0xffffe002] = -camera.foreground.x.u16
		RenderSprites()

		A0 = 0xfffffc42
		++emerald.animframe
		if (emerald.animframe >= 3)
			emerald.animframe = 0

		copyMemory(A0, 0x00ca9a, 0x1e)

		// Data Select
		if (global.game_mode != 0x4c)
			break
	}

	playSound(0xaf)
}

function bool Standalone.onWriteToSpriteTable(s16 px, s16 py, u16 renderQueue)
{
	u8 gameMode = global.game_mode & 0x7f

	if (gameMode == 0x4c || gameMode == 0x0c)
	{
		if (lsds.alphashadow && (objA0.mapping_offset == 0x00ce0e || objA0.mapping_offset == 0x20bd68))
		{
			
			if (objA0.update_address == 0x00d42c)
			{
				Renderer.drawCustomSprite("large_border", px, (lsds.nodetail) ? py - 0x10 : py, 0x00, 0, renderQueue - 100)
			}
			else if (objA0.update_address == 0x00d30c)
			{
				Renderer.drawCustomSprite("small_border", px, py, 0x00, 0, renderQueue - 100)
			}
			else if (objA0.update_address == 0x00d782)
			{
				Renderer.drawCustomSprite("small_border", 0x3c8 - camera.foreground.x.u16, py - 16, 0x00, 0, renderQueue - 100)
			}
		}
		
		// Hackey way to handle extra slot compat...
		if (lsds.nodetail && Mods.isModActive("Extra Character Slots") && objA0.update_address == 0x00d42c && objA0.animation.sprite == 0x05 && objA0.animation.timer > 0x00)
		{
			
			if (u8[A0 + 0x38] == 0xff && objA0.animation.sprite == 5 && objA0.animation.timer != 0 && u16[0xffffb04a + 0x30] == 0)
			{	
				u64 portrait = 0
				u64 portraitesp = 0
				if (u8[A0 + 0x23] == 0x18)
					portrait = stringformat("dataSel_savePortrait_slot%d", objA0.animation.timer)
				else if (u8[A0 + 0x23] == 0x19)
					portrait = stringformat("dataSel_savePortrait_superslot%d", objA0.animation.timer)
				else if (u8[A0 + 0x23] == 0x1b)
				{
					portrait = stringformat("dataSel_savePortrait_clear_slot%d", objA0.animation.timer)
					portraitesp = stringformat("Clear_slot%d", objA0.animation.timer)
				}

				if (Renderer.hasCustomSprite(portrait))
				{
					Renderer.drawCustomSprite(portrait, px, py - 16, 0, SPRITE_FLAG_PRIO, renderQueue - 100)
					u8[A0 + 0x23] = 0
				}
				
				if (Renderer.hasCustomSprite(portraitesp))
				{
					Renderer.drawCustomSprite(portraitesp, px, py - 16, 0, SPRITE_FLAG_PRIO, renderQueue - 100)
					u8[A0 + 0x23] = 0
				}
			}
			
			if (Renderer.hasCustomSprite(stringformat("dataSel_slot%d", objA0.animation.timer)))
			{
				u64 charactersprite = "dataSel_slot%d"
				if (objA0.animation.timer == 1 && (Mods.isModActive("Extra Slot Mighty") || Mods.isModActive("Extra Slot Mighty SHC")) && System.getGlobalVariableValueByName("Mighty_Sprite_type") == 1)
					charactersprite = "S3_portrait"
					
				Renderer.drawSprite(stringformat(charactersprite, objA0.animation.timer), px, py, (objA0.animation.timer > 0x03) ? 0xff : 0x40 + (objA0.animation.timer + 0x02) * 0x20, SPRITE_FLAG_PRIO, renderQueue)
			}
			
			return false
			
		}
		else if (Mods.isModActive("Extra Character Slots"))
		{
			renderQueue -= 100
		}
	}

	

	
	return base.Standalone.onWriteToSpriteTable(px, py, renderQueue)
}

//# address-hook(0x001506) end(0x00da1c)
function void fn001506()
{
	if (lsds.alphashadow && ((D0.u16 == D7.u16 - 2) && (A2 != 0x200000 + u32[0x3a216a + D0.s16])))
		return

	if (lsds.alphashadow && (A1.u16 == 0x00 || A1.u16 == 0x104 || A1.u16 == 0x222))
		return

	base.fn001506()
}

//# address-hook(0x00d9f4) end(0x00da1c)
function void fn00d9f4()
{
	if (lsds.alphashadow && A1 == 0x00db36)
	{
		D0 -= 1
		// Render empty tiles
		A1 = 0x00db2b
		base.fn00d9f4()

		// Render "CLEAR" label
		A1 = 0x00db36
		D0.u16 = D7.u16
		base.fn00d9f4()
		
		return
	}
	else if (lsds.alphashadow && A1 == 0x00db2b)
	{
		D0 -= 1
		// Render empty tiles
		A1 = 0x00db2b
		base.fn00d9f4()
		
		return
	}

	base.fn00d9f4()
}

//# address-hook(0x00c97a) end(0x00ca12)
function void fn00c97a()
{
	if (lsds.nodetail)
		return
	
	base.fn00c97a()
}

//# address-hook(0x00d42c) end(0x00d69a)
function void fn00d42c()
{
	if (!lsds.nodetail)
	{
		base.fn00d42c()
		return
	}
	
	objA0.position.y.u16 = (oldposy != 0) ? oldposy : objA0.position.y.u16
	
	base.fn00d42c()
	
	oldposy = objA0.position.y.u16
	objA0.position.y.u16 += 0x10
}
