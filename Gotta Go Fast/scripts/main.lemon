global bool ggf.sonic
global bool ggf.knux
global bool ggf.supersonic
global bool ggf.superknux
global bool ggf.intro
global bool ggf.knuxddz
global bool ggf.speed
global bool ggf.esu.mighty
global bool ggf.esu.supermighty
global bool ggf.esu.ray
global bool ggf.esu.amy
global bool ggf.esu.superamy
global bool ggf.esu.shadow
global bool ggf.esu.supershadow

define u8 global.xtrachar	= u8[0xffffe654]

function bool Standalone.drawCharacterSprite(u8 character, u8 variant, s16 px, s16 py, bool asSmallGhost)
{
	bool isPlayer1 = (variant == 0)
	u32 characterAddress = isPlayer1 ? 0xffffb000 : 0xffffb04a

	// Check only needed for Tails' tails
	if (variant >= 2)
	{
		return base.Standalone.drawCharacterSprite(character, variant, px, py, asSmallGhost)
	}

	if (level.vertical_wrap == 0xff00)
	{
		// For vertically wrapping levels, "normalize" py into interval [-move_area.bottom.target * 3/4, -move_area.bottom.target * 1/4]
		py &= level.height.bitmask
		if (py > move_area.bottom.target * 3/4 && move_area.bottom.target >= 0xe0)	// move_area.bottom.target is very low in DEZ boss act
			py -= move_area.bottom.target
	}

	u8 animationSprite = char.animation.sprite
	u16 animationSpriteEx = Standalone.getModdedAnimationSpriteEx(character, animationSprite)
	u8 flags = (char.render_flags & (SPRITE_FLAG_FLIP_X | SPRITE_FLAG_FLIP_Y))
	u8 angle = 0
	u64 key = Standalone.getModdedAnimationSpriteKey(character, animationSpriteEx)		// First ask modded scripts

	sonic.fastrunanim.timer = 0
	
	u16 regularspeed = ggf.speed ? 0xc00 : 0xa00
	u16 superspeed =  ggf.speed ? 0xc00 : 0xb00


	if (global.xtrachar == 0 && character == CHARACTER_SONIC && animationSpriteEx == animationSprite && !super.active && animationSprite >= 0x21 && animationSprite <= 0x30 && abs(char.groundspeed) >= regularspeed && ggf.sonic)
	{
		animationSpriteEx = CHAR_ANIMSPRITE_SONIC_PEELOUT + (level.framecounter & 0x03)
		key = stringformat("sonic_fast_run_%d", animationSpriteEx - CHAR_ANIMSPRITE_SONIC_PEELOUT)
	}
	else if (global.xtrachar == 0 && character == CHARACTER_SONIC && animationSpriteEx == animationSprite && super.active && animationSprite >= 0x21 && animationSprite <= 0x30 && (abs(char.groundspeed) >= superspeed || (isSonicIntro() && ggf.intro)) && ggf.supersonic)
	{
		animationSpriteEx = CHAR_ANIMSPRITE_SONIC_PEELOUT + (level.framecounter & 0x03)
		key = stringformat("super_sonic_fast_run_%d", animationSpriteEx - CHAR_ANIMSPRITE_SONIC_PEELOUT)
	}
	else if (global.xtrachar == 0 && character == CHARACTER_KNUCKLES && animationSpriteEx == animationSprite && !super.active && animationSprite >= 0x21 && animationSprite <= 0x30 && abs(char.groundspeed) >= regularspeed && ggf.knux)
	{
		animationSpriteEx = CHAR_ANIMSPRITE_SONIC_PEELOUT + (level.framecounter & 0x03)
		key = stringformat("knuckles_fast_run_%d", animationSpriteEx - CHAR_ANIMSPRITE_SONIC_PEELOUT)
	}
	else if (global.xtrachar == 0 && character == CHARACTER_KNUCKLES && animationSpriteEx == animationSprite && super.active && animationSprite >= 0x21 && animationSprite <= 0x30 && (abs(char.groundspeed) >= superspeed) && ggf.superknux)
	{
		animationSpriteEx = CHAR_ANIMSPRITE_SONIC_PEELOUT + (level.framecounter & 0x03)
		key = stringformat("super_knuckles_fast_run_%d", animationSpriteEx - CHAR_ANIMSPRITE_SONIC_PEELOUT)
	}
	else if (global.xtrachar == 1 && character == CHARACTER_SONIC && animationSpriteEx == animationSprite && !super.active && animationSprite >= 0x21 && animationSprite <= 0x30 && abs(char.groundspeed) >= regularspeed && ggf.esu.mighty)
	{
		animationSpriteEx = CHAR_ANIMSPRITE_SONIC_PEELOUT + (level.framecounter & 0x03)
		u64 Spritekey = (System.getGlobalVariableValueByName("Mighty_Sprite_type")) ? "S3_m" : "m"

		key = stringformat("%sighty_fastrun_%d", Spritekey, animationSpriteEx - CHAR_ANIMSPRITE_SONIC_PEELOUT)
	}
	else if (global.xtrachar == 1 && character == CHARACTER_SONIC && animationSpriteEx == animationSprite && super.active && animationSprite >= 0x21 && animationSprite <= 0x30 && (abs(char.groundspeed) < superspeed) && ggf.esu.supermighty)
	{
		animationSpriteEx = 0x21 + (level.framecounter & 0x03)
		key = (System.getGlobalVariableValueByName("Mighty_Sprite_type")) ? "character_slot1_S3_0x%02x" : "character_slot1_0x%02x"

		key = stringformat(key, animationSpriteEx)
	}
	else if (global.xtrachar == 2 && character == CHARACTER_TAILS && animationSpriteEx == animationSprite && animationSprite >= 0x21 && animationSprite <= 0x30 && (abs(char.groundspeed) >= regularspeed) && ggf.esu.ray)
	{
		animationSpriteEx = 0xda + (level.framecounter & 0x03)
		key = (System.getGlobalVariableValueByName("Ray_Sprite_type")) ? "character_slot2_0x%02x" : "Mania_Ray_0x%02x"

		key = stringformat(key, animationSpriteEx)
	}
	else if (global.xtrachar == 3 && character == CHARACTER_TAILS && animationSpriteEx == animationSprite && !super.active.tails && animationSprite >= 0x21 && animationSprite <= 0x30 && abs(char.groundspeed) >= regularspeed && ggf.esu.amy)
	{
		animationSpriteEx = 0xbd + (level.framecounter & 0x03)

		key = stringformat("character_amy_0x%02x", animationSpriteEx)
	}
	else if (global.xtrachar == 3 && character == CHARACTER_TAILS && animationSpriteEx == animationSprite && super.active.tails && animationSprite >= 0x21 && animationSprite <= 0x30 && (abs(char.groundspeed) < superspeed) && ggf.esu.superamy)
	{	
		animationSpriteEx = 0x21 + (animationSprite & 3)
		key = stringformat("character_amy_0x%02x", animationSpriteEx)
	}
	else if (global.xtrachar == 5 && character == CHARACTER_SONIC && animationSpriteEx == animationSprite && !super.active && animationSprite >= 0x21 && animationSprite <= 0x30 && abs(char.groundspeed) >= regularspeed && ggf.esu.shadow)
	{
		if (System.getGlobalVariableValueByName("shadow.airBoost") && !System.getGlobalVariableValueByName("shadow.waterRun"))
			return base.Standalone.drawCharacterSprite(character, variant, px, py, asSmallGhost)
			
		animationSpriteEx = CHAR_ANIMSPRITE_SONIC_PEELOUT + (level.framecounter & 0x03)

		key = stringformat("shadow_fast_run_%d", animationSpriteEx - CHAR_ANIMSPRITE_SONIC_PEELOUT)
	}
	else if (global.xtrachar == 5 && character == CHARACTER_SONIC && animationSpriteEx == animationSprite && super.active && animationSprite >= 0x21 && animationSprite <= 0x30 && (abs(char.groundspeed) < superspeed) && ggf.esu.supershadow)
	{
		if (System.getGlobalVariableValueByName("shadow.isBoosting") && char.flags & char.flag.IN_AIR)
			return base.Standalone.drawCharacterSprite(character, variant, px, py, asSmallGhost)
			
		animationSpriteEx = 0x21 + (animationSprite - 0x21) % 4

		if (System.getGlobalVariableValueByName("shadow.FrameCounter") == 0)
		{
			System.setGlobalVariableValueByName("shadow.RunFrameOld", animationSprite)
			System.setGlobalVariableValueByName("shadow.FrameCounter", 3)
		}
		if (System.getGlobalVariableValueByName("shadow.RunFrameOld") != animationSprite)
		{ //go up to 24 then restart to 2
			if (System.getGlobalVariableValueByName("shadow.FrameCounter") < 38)
			{
				System.setGlobalVariableValueByName("shadow.FrameCounter", System.getGlobalVariableValueByName("shadow.FrameCounter") + 1)
			}
			else
			{
				System.setGlobalVariableValueByName("shadow.FrameCounter", 3)
			}
		}
		key = (System.getGlobalVariableValueByName("ESShadow.shadowsprites") == 0) ? stringformat("shadow_run_%d", System.getGlobalVariableValueByName("shadow.FrameCounter")/3) : stringformat("shadow_run_old_%d", System.getGlobalVariableValueByName("shadow.FrameCounter")/3)
		System.setGlobalVariableValueByName("shadow.RunFrameOld", animationSprite)
	}
	else
	{
		return base.Standalone.drawCharacterSprite(character, variant, px, py, asSmallGhost)
	}
	
	
//copy start
	if (!Game.getSetting(SETTING_SMOOTH_ROTATION))
	{
		angle = (animationSprite - 0x21) / 4 * 0xe0
		if ((char.flags & char.flag.FACING_LEFT) == (global.inv_gravity == 0))
			angle = -angle
		animationSprite = 0x21 + (animationSprite - 0x21) % 4
	}
	else if (Game.getSetting(SETTING_SMOOTH_ROTATION))
	{
		bool useVanillaS3AIRRotation = true
		if (Game.getSetting(SETTING_SMOOTH_ROTATION) == 2)
		{
			useVanillaS3AIRRotation = (char.flags & char.flag.IN_AIR || global.zone == 0x0c)	// Use in-air rotation in DDZ
		}

		if (useVanillaS3AIRRotation)
		{
			s8 oldRotation = isPlayer1 ? oldRotationPlayer1 : oldRotationPlayer2
			flags = char.flags & char.flag.FACING_LEFT		// This really has to be "char.flags", not "char.render_flags"

			angle = char.rotation
			
			if (abs(s8(char.rotation)) <= 0x10 && abs(oldRotation) <= 0x10)
			{
				angle = 0
			}

			if (angle != char.rotation)
			{
				s8 diff = angle - oldRotation
				angle = oldRotation + clamp(diff, -3, 3)
			}
		}
		else
		{
			// Mania-accurate rotation #contributed by Elsie The Pict
			u8 oldRotation = isPlayer1 ? oldRotationPlayer1 : oldRotationPlayer2
			flags = char.flags & char.flag.FACING_LEFT		// This really has to be "char.flags", not "char.render_flags"

			angle = char.rotation

			if (char.rotation <= 0x04 || char.rotation >= 0xfc)
			{
				oldRotation = 0
			}
			else
			{
				u32 targetRotation = 0
				if (char.rotation > 0x10 && char.rotation < 0xe8)
					targetRotation = char.rotation

				u32 rotate = targetRotation - oldRotation
				u32 shift = (abs(char.groundspeed) <= 0x6000) + 1

				if (abs(rotate) >= abs(rotate - 0x100))
				{
					if (abs(rotate - 0x200) < abs(rotate + 0x100))
						oldRotation += (rotate - 0x100) >> shift
					else
						oldRotation += (rotate + 0x100) >> shift
				}
				else
				{
					if (abs(rotate) < abs(rotate + 0x100))
						oldRotation += rotate >> shift
					else
						oldRotation += (rotate + 0x100) >> shift
				}
			}

			angle = oldRotation & 0xff
		}


		if (isPlayer1)
			oldRotationPlayer1 = angle
		else
			oldRotationPlayer2 = angle
	}
// copy finish

	u16 renderQueue = 0xa000 - char.sprite_priority
	u8 atex = (char.sprite_attributes >> 9) & 0x30
	if (EXTENDED_CHARACTER_PALETTES)
		atex = 0x40 + character * 0x20

	if (char.sprite_attributes & sprite_attribute.PRIORITY)
		flags |= SPRITE_FLAG_PRIO

	if (global.inv_gravity)
	{
		// Correction for inverse gravity
		angle = 128 - angle
		flags ^= SPRITE_FLAG_FLIP_X
	}

	if (ROMDataAnalyser.isEnabled())
	{
		string category = (variant < 2) ? getCharacterSpriteKey(character) : stringformat("%s_tails", getCharacterSpriteKey(CHARACTER_TAILS))
		Renderer.extractCustomSprite(key, category, animationSprite, atex)
	}

	// Render character
	if (asSmallGhost)
	{
		Renderer.drawCustomSprite(key, px, py, atex, flags | SPRITE_FLAG_PRIO, 0xa800, angle, 0xc0ffffff, 0x8000)
	}
	else
	{
		Renderer.drawCustomSprite(key, px, py, atex, flags, renderQueue, angle, 255)
	}

	bool useAfterImages
	if (isPlayer1)
	{
		if ((super.active == 0xff) || (super.active.tails == 0xff))
		{
			useAfterImages = true
		}
		else
		{
			if (Game.getSetting(SETTING_SPEEDUP_AFTERIMGS))
			{
				useAfterImages = ((u8[characterAddress + 0x2b] & char.bonus.SPEED_UP) != 0)
			}
		}
	}

	if (global.xtrachar == 5)
	{
		//boost wave - whevener a boost is initiated
		if (System.getGlobalVariableValueByName("shadow.BoostWave") > 0)
		{
			if (System.getGlobalVariableValueByName("shadow.BoostWave") == 1) //set the coordinates and the starting old camera
			{
				System.setGlobalVariableValueByName("shadow.BoostPX", px)
				System.setGlobalVariableValueByName("shadow.BoostPY", py)
				System.setGlobalVariableValueByName("shadow.BoostOLDX", camera.position.x.u16)
				System.setGlobalVariableValueByName("shadow.BoostOLDY", camera.position.y.u16)
			}
			//calculate where the effect moves on screen then set old camera coords
			System.setGlobalVariableValueByName("shadow.BoostPX", System.getGlobalVariableValueByName("shadow.BoostPX") + (System.getGlobalVariableValueByName("shadow.BoostOLDX") - camera.position.x.u16))
			System.setGlobalVariableValueByName("shadow.BoostPY", System.getGlobalVariableValueByName("shadow.BoostPY") + (System.getGlobalVariableValueByName("shadow.BoostOLDY") - camera.position.y.u16))
			System.setGlobalVariableValueByName("shadow.BoostOLDX", camera.position.x.u16)
			System.setGlobalVariableValueByName("shadow.BoostOLDY", camera.position.y.u16)
			
			u64 key3 = stringformat("shadow_boost_start_%d", System.getGlobalVariableValueByName("shadow.BoostWave")/2 )
			//account for gravity --> 0x02		
			Renderer.drawCustomSprite(key3, System.getGlobalVariableValueByName("shadow.BoostPX"), System.getGlobalVariableValueByName("shadow.BoostPY"), atex, flags, renderQueue+1, 0, 200)
			//Increase the counter and "kill" the object if needed
			System.setGlobalVariableValueByName("shadow.BoostWave", System.getGlobalVariableValueByName("shadow.BoostWave") + 1)
			if (System.getGlobalVariableValueByName("shadow.BoostWave") >=10)
				System.setGlobalVariableValueByName("shadow.BoostWave", 0)
		}
	//boost Flame -- just like the drop, but uses Shadow's angle too
	//this one needs more work -> be angled on the carnival night bars
	//be turned on horizontal circle running (aiz1 fbz...) done in airdash animation above
	//also turn off the boost on non vertical spinning animations in hcz, cnz, ssz...
		if (System.getGlobalVariableValueByName("shadow.isBoosting"))
		{
			if (char.state == char.state.RUNNING)
			{
				u64 key3 = stringformat("shadow_boost_%d", level.framecounter & 0x03)
				if (global.zone == 0x03 && (animationSprite >= 0x49 && animationSprite <= 0x54)) //carnival night pole. fbz uses some frames when entering cylinders, so I have to check the stage
				{
					if (System.getGlobalVariableValueByName("shadow.rtlcnzbar"))
						Renderer.drawCustomSprite(key3, px, py, atex, flags, renderQueue+1, 0xe0, 200)
					else
						Renderer.drawCustomSprite(key3, px, py, atex, flags, renderQueue+1, 0x20, 200)
				}
				else if (animationSprite >= 0x69 && animationSprite <= 0x77)||(animationSprite >= 0x49 && animationSprite <= 0x54)
				{ //if boosting on horizontal circle animation must account for the x position difference for the direction
					if (char.position.x.u16 >= System.getGlobalVariableValueByName("shadow.BoostXTRACK")) //no angle
						Renderer.drawCustomSprite(key3, px, py, atex, 0x00, renderQueue+1, 0x00, 200)
					else //flip X, no angle
						Renderer.drawCustomSprite(key3, px, py, atex, 0x01, renderQueue+1, 0x00, 200)
				}
				else //normal
					Renderer.drawCustomSprite(key3, px, py, atex, flags, renderQueue+1, angle, 200)
				
				System.setGlobalVariableValueByName("shadow.BoostXTRACK", char.position.x.u16)
			}
			else
				System.setGlobalVariableValueByName("shadow.isBoosting", false)
		}
		
		if (isPlayer1)
		{
			//Handle shadow's homing and boost as well
			if (System.getGlobalVariableValueByName("shadow.isBoosting") || System.getGlobalVariableValueByName("shadow.Homing") == 2)
				useAfterImages = true
		}
		
	//SHADOW EFFECTS - END
	}

	if (useAfterImages)
	{
		// Additional offset for Sonic charging a Super Peel-Out (either Hyper Sonic or with Speed Shoes)
		s16 afterImagesOffsetX = 0
		if (char.character == CHARACTER_SONIC && char.spindash == 0x80)
		{
			afterImagesOffsetX = (char.groundspeed >> 7) * ((char.flags & char.flag.FACING_LEFT) ? 1 : -1)
		}

		for (s8 i = 3; i > 0; --i)
		{
			A1 = 0xffffe500 + u8(posbackup.offset.player1 - (i * 8 + 4))
			s16 px0 = u16[A1] - camera.foreground.x.u16 + (i * afterImagesOffsetX / 4)
			s16 py0 = u16[A1+2] - camera.foreground.y.u16
			if (level.vertical_wrap == 0xff00)	// Consider vertical level wrap
				py0 &= level.height.bitmask

			Renderer.setSpriteTagWithPosition(characterAddress + 0x10 + i, px0, py0)
			Renderer.drawCustomSprite(key, px0, py0, atex, flags, renderQueue - i, angle, 192 - i * 32)
		}
	}

	// Prevent emulator-like rendering
	return true
}

//# address-hook(0x08167c) end(0x0816ee)
function void fn08167c()
{
	if (!ggf.knuxddz)
	{
		base.fn08167c()
	}
	
	objA0.velocity.y -= 0x20
	UpdateMovementStraightSimple()

	A1 = 0xffffb000
	if (u8[A1 + 0x2e] != 0)
		return

	objA0.base_state = 0x06
	objA0.velocity.x = 0
	objA0.velocity.y = 0
	objA0.flags38 |= 0x04
	u8[A1 + 0x2e] = 0x01
	objA1.state = char.state.RUNNING
	objA1.velocity.x = 0x1000
	u16[A1 + 0x1c] = 0x1000

	if (global.super_emeralds != 7)
	{
		u32[0xffffcbc0] = 0x08242a		// Super Sonic stars in Doomsday Zone
	}
	else
	{
		fn05fcce()
		u32[0xffffcd7c] = 0x019348		// Hyper Sonic stars
		u32[0xffffcbc0] = 0x01a494		// After-images effect
	}

	addPatternLoadingCue(0x083d64)
}